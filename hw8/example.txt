func main() {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel() // Make sure all paths cancel the context to avoid context leak

	errc := make(chan error) // Channel for errors from the worker goroutines

	// Start the worker goroutines
	go func() { errc <- processPayments(ctx) }()
	go func() { errc <- manageInventory(ctx) }()
	go func() { errc <- verifyCustomer(ctx) }()

	// Wait for any of the goroutines to return an error. If one does,
	// cancel the context to stop the others.
	select {
	case err := <-errc:
		if err != nil {
			fmt.Println("error:", err)
			cancel()
		}
	case <-ctx.Done():
		fmt.Println("operation completed successfully")
	}
}

// Worker goroutines send any error they encounter to the main goroutine
// instead of cancelling the context themselves.
func processPayments(ctx context.Context) error {
	// ...
}

func manageInventory(ctx context.Context) error {
	// ...
}

func verifyCustomer(ctx context.Context) error {
	// ...
}

